"""Abstract base class for trading strategies."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Optional

import pandas as pd

from ..data.market_data import MarketData


class SignalType(str, Enum):
    """Type of trading signal."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


class ExitReason(str, Enum):
    """Reason for exit signal."""
    STOP_LOSS = "stop_loss"
    TRAILING_STOP = "trailing_stop"
    TAKE_PROFIT = "take_profit"
    SIGNAL = "signal"  # Strategy signal to exit
    MANUAL = "manual"
    END_OF_DAY = "end_of_day"
    CIRCUIT_BREAKER = "circuit_breaker"


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    symbol: str
    signal_type: SignalType
    strength: float  # 0.0 to 1.0
    price: float
    reason: str
    strategy_name: str
    timestamp: datetime = field(default_factory=datetime.now)

    # Suggested order parameters
    suggested_quantity: Optional[int] = None
    suggested_stop_loss: Optional[float] = None
    suggested_take_profit: Optional[float] = None

    # Indicator values at signal time
    indicators: dict[str, Any] = field(default_factory=dict)

    def __repr__(self) -> str:
        return (
            f"<Signal({self.signal_type.value} {self.symbol} @ ${self.price:.2f}, "
            f"strength={self.strength:.2f}, reason='{self.reason}')>"
        )


@dataclass
class ExitSignal:
    """Signal to exit an existing position."""
    symbol: str
    reason: ExitReason
    exit_price: float
    description: str
    timestamp: datetime = field(default_factory=datetime.now)
    urgency: str = "normal"  # normal, high, immediate

    def __repr__(self) -> str:
        return (
            f"<ExitSignal({self.symbol} @ ${self.exit_price:.2f}, "
            f"reason={self.reason.value}, urgency={self.urgency})>"
        )


@dataclass
class PositionInfo:
    """Information about an open position (for strategy evaluation)."""
    symbol: str
    quantity: float
    avg_entry_price: float
    current_price: float
    unrealized_pnl: float
    unrealized_pnl_pct: float
    highest_price: float  # For trailing stop calculation
    stop_loss_price: Optional[float] = None
    trailing_stop_price: Optional[float] = None
    take_profit_price: Optional[float] = None
    opened_at: Optional[datetime] = None


class Strategy(ABC):
    """
    Abstract base class for trading strategies.

    Strategies must implement:
    - generate_signals: Analyze market data and generate buy/sell signals
    - should_exit: Check if an existing position should be closed
    """

    def __init__(self, name: str, config: dict[str, Any] | None = None):
        self.name = name
        self.config = config or {}
        self._is_active = True

    @property
    def is_active(self) -> bool:
        """Whether the strategy is currently active."""
        return self._is_active

    def activate(self) -> None:
        """Activate the strategy."""
        self._is_active = True

    def deactivate(self) -> None:
        """Deactivate the strategy."""
        self._is_active = False

    @abstractmethod
    def generate_signals(
        self,
        market_data: dict[str, MarketData],
        current_positions: dict[str, PositionInfo],
    ) -> list[Signal]:
        """
        Analyze market data and generate trading signals.

        Args:
            market_data: Dict mapping symbol to MarketData
            current_positions: Dict mapping symbol to PositionInfo for open positions

        Returns:
            List of Signal objects for recommended actions
        """
        pass

    @abstractmethod
    def should_exit(
        self,
        position: PositionInfo,
        market_data: MarketData,
    ) -> Optional[ExitSignal]:
        """
        Check if an existing position should be closed.

        Args:
            position: Information about the current position
            market_data: Current market data for the symbol

        Returns:
            ExitSignal if position should be closed, None otherwise
        """
        pass

    def calculate_position_size(
        self,
        signal: Signal,
        account_value: float,
        max_position_pct: float,
        current_price: float,
    ) -> int:
        """
        Calculate suggested position size based on signal strength and risk parameters.

        Args:
            signal: The generated signal
            account_value: Total account value
            max_position_pct: Maximum position size as percentage of account
            current_price: Current stock price

        Returns:
            Number of shares to trade
        """
        # Base allocation on signal strength and max position size
        allocation_pct = max_position_pct * signal.strength
        allocation_value = account_value * allocation_pct

        # Calculate shares (round down to whole shares)
        shares = int(allocation_value / current_price)

        return max(0, shares)

    def calculate_stop_loss(
        self,
        entry_price: float,
        stop_loss_pct: float,
        is_long: bool = True,
    ) -> float:
        """Calculate stop loss price."""
        if is_long:
            return entry_price * (1 - stop_loss_pct)
        else:
            return entry_price * (1 + stop_loss_pct)

    def calculate_take_profit(
        self,
        entry_price: float,
        take_profit_pct: float,
        is_long: bool = True,
    ) -> float:
        """Calculate take profit price."""
        if is_long:
            return entry_price * (1 + take_profit_pct)
        else:
            return entry_price * (1 - take_profit_pct)

    def calculate_trailing_stop(
        self,
        highest_price: float,
        trailing_stop_pct: float,
        is_long: bool = True,
    ) -> float:
        """Calculate trailing stop price based on highest price since entry."""
        if is_long:
            return highest_price * (1 - trailing_stop_pct)
        else:
            return highest_price * (1 + trailing_stop_pct)

    def get_config_value(self, key: str, default: Any = None) -> Any:
        """Get a configuration value with a default."""
        return self.config.get(key, default)

    def __repr__(self) -> str:
        return f"<Strategy(name={self.name}, active={self._is_active})>"
